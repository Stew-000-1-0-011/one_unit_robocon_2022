このパッケージはc++20で無理やりビルドすることが推奨される()
C++20で無理やりビルド -> ```Alloc::rebind<T>::other```によるエラーなどが山のように出現
-> 全部```std::allocator_traits<Alloc>::rebind_alloc<T>```に変更などする
-> 確証はないが動く！()

こういうノリで書かれた。だってコンセプト使ってみたかったんだもの...。
どうもこれで動くって言っている人が多い気もする。

とりあえずg++-9で動くことを目標に書いている。あとGNU拡張が入ってたはず(constexprな数学関数など)。
g++-11でビルドしてもらえるととても嬉しい。

```ros::Publisher```や```ros::Subscriber```などはスレッドセーフであるらしい。どのレベルでスレッドセーフなのかわからないけど、わからない。
ので、とりあえず大丈夫だと仮定してstaticな変数にしたりしている。並行化してこわれたらごめん。

gccで```<execution>```関連を使うには、oneTBBをリンクする必要があるらしい。めんどいのでこっそり使われないように変更した...
(ちなみに計測もなにもしていない)

例外がわからない。まじでわからない...どこで急に制御が飛ぶかわからないものをどう使えというんだ。
-> ほぼ全ての関数はnoexcept指定されている。catchする気が無い例外、すなわち全ての例外は至る所で握りつぶされます。(```std::terminate```、つまり```std::abort```)
追記: 最近少し例外に興味が出てきたのでnoexceptベタ塗りじゃなくなってきた。noexcept(auto)とかあると楽なんだけどな...
Stewがつかわないので```bad_typeid```も```bad_cast```も捕捉しない、```bad_alloc```も怠惰なので捕捉してない(スタックは確認しないんだし...よっぽど大きくなきゃ良くない？)。

例外の扱いについて意見が欲しいです。

ポインタ嫌いな人が多いので、コピーやムーブできて参照先を変更できる参照のような(pointer-likeならぬreference-likeな)型を作りたかった。
でも````operator.()```がオーバーロードできないので断念。
(できたとして、参照先のオブジェクトからとそのreference-likeなオブジェクト自体からのメンバ呼び出しを区別するのかわからないけど。
誰か```operator.()```のオーバーロードに関する提案を訳してほしい...。)

rosparamを積極的に使うようにしました。テストが楽になりました。

Nodeletによる複数スレッドについて
ros::Publisher::publishはスレッドセーフらしい(噂)が、そのオブジェクトに関する全ての操作がスレッドセーフというわけではないようだ。
扱いには十分に気を付けること。if(pub)とか書いてるコードを複数スレッドから実行するのは危険だと思う。

やはりros:Publisherをラップしたクラスを作るべきなのでは...？

どうにもros::Publisherの中身の把握ができずやめたんだっけ。まあやめた。

どうもnodeletの```GetMTNodeHandle```を使うとcallbackはどれも並列して実行され得るみたいだ。
だから、スレッドセーフかどうかを意識して書かないといけない。
......マジで誰かレビューしてくれんかなぁ...