このパッケージはc++20で無理やりビルドすることが推奨される()
C++20で無理やりビルド -> Alloc::rebind<T>::otherによるエラーなどが山のように出現
-> 全部std::allocator_traits<Alloc>::rebind_alloc<T>に変更などする
-> 確証はないが動く！()

こういうノリで書かれた。だってコンセプト使ってみたかったんだもの...。

とりあえずg++-9で動くことを目標に書いている。あとGNU拡張が入ってたはず(constexprな数学関数など)。
g++-11でビルドしてもらえるととても嬉しい。

ros::Publisherやros::Subscriberなどはスレッドセーフであるらしい。どのレベルでスレッドセーフなのかわからないけど、わからない。
ので、とりあえず大丈夫だと仮定してstaticな変数にしたりしている。並行化してこわれたらごめん。

gccで<execution>関連を使うには、oneTBBをリンクする必要があるらしい。めんどいのでこっそり使われないように変更した...
(ちなみに計測もなにもしていない)

例外がわからない。まじでわからない...どこで急に制御が飛ぶかわからないものをどう使えというんだ。
-> ほぼ全ての関数はnoexcept指定されている。catchする気が無い例外、すなわち全ての例外は至る所で握りつぶされます。(std::terminate、つまりstd::abort)
Stewがつかわないのでbad_typeidもbad_castも捕捉しない、bad_allocも怠惰なので捕捉してない(スタックは確認しないんだし...よっぽど大きくなきゃ良くない？)。

例外の扱いについて意見が欲しいです。

ポインタ嫌いな人が多いので、コピーやムーブできて参照先を変更できる参照のような(pointer-likeならぬreference-likeな)型を作りたかった。
でもoperator.()がオーバーロードできないので断念。
(できたとして、参照先のオブジェクトからとそのreference-likeなオブジェクト自体からのメンバ呼び出しを区別するのかわからないけど。
誰かoperator.()のオーバーロードに関する提案を訳してほしい...。)

rosparamを積極的に使うようにしました。テストが楽になりました。